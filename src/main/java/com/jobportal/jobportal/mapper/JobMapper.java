package com.jobportal.jobportal.mapper;

import com.jobportal.jobportal.dto.*;
import com.jobportal.jobportal.entity.Job;

import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * JobMapper - Static utility class for mapping between Job entity and DTOs.
 * 
 * This class provides static methods for:
 * - Converting Job entities to DTOs (JobDTO, JobDetailDTO)
 * - Converting DTOs to Job entities
 * - Applying DTO updates to existing entities
 * - Formatting data for frontend display (compensation, dates, job types)
 * - Transforming data structures (skills to keywords, requirements to arrays)
 * 
 * All methods are static and thread-safe. Null-safe operations are used throughout.
 * 
 * @author Job Portal Team
 * @version 1.0
 */
public class JobMapper {

    /**
     * Converts a Job entity to a JobDTO.
     * 
     * This method maps all fields from the Job entity to the JobDTO,
     * including the newly added companyInfo and companyLogoUrl fields.
     * Used for standard job data transfer operations.
     * 
     * @param job The Job entity to convert. Can be null.
     * @return JobDTO with all entity fields mapped, or null if job is null.
     * 
     * @example
     * <pre>
     * Job job = jobRepository.findById(1L).orElse(null);
     * JobDTO dto = JobMapper.jobEntityToDto(job);
     * </pre>
     */
    public static JobDTO jobEntityToDto(Job job) {
        if (job == null) return null;
        
        return JobDTO.builder()
                .id(job.getId())
                .title(job.getTitle())
                .company(job.getCompany())
                .location(job.getLocation())
                .jobType(job.getJobType())
                .status(job.getStatus())
                .experienceLevel(job.getExperienceLevel())
                .department(job.getDepartment())
                .category(job.getCategory())
                .description(job.getDescription())
                .requirements(job.getRequirements())
                .responsibilities(job.getResponsibilities())
                .benefits(job.getBenefits())
                .salaryMin(job.getSalaryMin())
                .salaryMax(job.getSalaryMax())
                .salaryCurrency(job.getSalaryCurrency())
                .workMode(job.getWorkMode())
                .educationLevel(job.getEducationLevel())
                .skills(job.getSkills())
                .companyInfo(job.getCompanyInfo())
                .companyLogoUrl(job.getCompanyLogoUrl())
                .postedBy(job.getPostedBy())
                .applicationDeadline(job.getApplicationDeadline())
                .startDate(job.getStartDate())
                .createdAt(job.getCreatedAt())
                .updatedAt(job.getUpdatedAt())
                .build();
    }

    /**
     * Converts a JobDTO to a Job entity.
     * 
     * This method is primarily used for creating new Job entities from DTOs.
     * The ID field is set from the DTO but will typically be null for new entities
     * (auto-generated by the database). Timestamps (createdAt, updatedAt) are set
     * from the DTO if provided, but are typically handled by @PrePersist and @PreUpdate
     * annotations in the entity.
     * 
     * @param dto The JobDTO to convert. Can be null.
     * @return Job entity with all DTO fields mapped, or null if dto is null.
     * 
     * @example
     * <pre>
     * JobDTO dto = JobDTO.builder()
     *     .title("Software Engineer")
     *     .company("Tech Corp")
     *     .build();
     * Job job = JobMapper.dtoToEntity(dto);
     * Job saved = jobRepository.save(job);
     * </pre>
     */
    public static Job dtoToEntity(JobDTO dto) {
        if (dto == null) return null;
        
        return Job.builder()
                .id(dto.getId()) // Typically null for new entities; auto-generated by DB
                .title(dto.getTitle())
                .company(dto.getCompany())
                .location(dto.getLocation())
                .jobType(dto.getJobType())
                .status(dto.getStatus())
                .experienceLevel(dto.getExperienceLevel())
                .department(dto.getDepartment())
                .category(dto.getCategory())
                .description(dto.getDescription())
                .requirements(dto.getRequirements())
                .responsibilities(dto.getResponsibilities())
                .benefits(dto.getBenefits())
                .salaryMin(dto.getSalaryMin())
                .salaryMax(dto.getSalaryMax())
                .salaryCurrency(dto.getSalaryCurrency())
                .workMode(dto.getWorkMode())
                .educationLevel(dto.getEducationLevel())
                .skills(dto.getSkills())
                .companyInfo(dto.getCompanyInfo())
                .companyLogoUrl(dto.getCompanyLogoUrl())
                .postedBy(dto.getPostedBy())
                .applicationDeadline(dto.getApplicationDeadline())
                .startDate(dto.getStartDate())
                .createdAt(dto.getCreatedAt())
                .updatedAt(dto.getUpdatedAt())
                .build();
    }

    /**
     * Applies JobDTO fields to an existing Job entity (for update operations).
     * 
     * This method updates the target Job entity with values from the DTO.
     * It does not update the ID, createdAt, or updatedAt fields:
     * - ID remains unchanged (cannot be updated)
     * - createdAt is immutable (handled by @PrePersist)
     * - updatedAt is automatically set by @PreUpdate annotation
     * 
     * All other fields from the DTO are applied to the target entity.
     * This method is null-safe and will return early if either parameter is null.
     * 
     * @param dto The JobDTO containing the updated values. Can be null.
     * @param target The existing Job entity to update. Can be null.
     * 
     * @example
     * <pre>
     * Job existing = jobRepository.findById(1L).orElseThrow();
     * JobDTO updates = JobDTO.builder()
     *     .title("Senior Software Engineer")
     *     .salaryMin(new BigDecimal("120000"))
     *     .build();
     * JobMapper.apply(updates, existing);
     * jobRepository.save(existing); // updatedAt will be set automatically
     * </pre>
     */
    public static void apply(JobDTO dto, Job target) {
        if (dto == null || target == null) return;
        
        target.setTitle(dto.getTitle());
        target.setCompany(dto.getCompany());
        target.setLocation(dto.getLocation());
        target.setJobType(dto.getJobType());
        target.setStatus(dto.getStatus());
        target.setExperienceLevel(dto.getExperienceLevel());
        target.setDepartment(dto.getDepartment());
        target.setCategory(dto.getCategory());
        target.setDescription(dto.getDescription());
        target.setRequirements(dto.getRequirements());
        target.setResponsibilities(dto.getResponsibilities());
        target.setBenefits(dto.getBenefits());
        target.setSalaryMin(dto.getSalaryMin());
        target.setSalaryMax(dto.getSalaryMax());
        target.setSalaryCurrency(dto.getSalaryCurrency());
        target.setWorkMode(dto.getWorkMode());
        target.setEducationLevel(dto.getEducationLevel());
        target.setSkills(dto.getSkills());
        target.setCompanyInfo(dto.getCompanyInfo());
        target.setCompanyLogoUrl(dto.getCompanyLogoUrl());
        target.setPostedBy(dto.getPostedBy());
        target.setApplicationDeadline(dto.getApplicationDeadline());
        target.setStartDate(dto.getStartDate());
        // Note: ID, createdAt, and updatedAt are not updated:
        // - ID cannot be changed
        // - createdAt is immutable (set only on creation)
        // - updatedAt is automatically set by @PreUpdate annotation
    }

    /**
     * Converts a comma-separated skills string to a list of keywords.
     * 
     * This method is used to transform the skills field (stored as a comma-separated
     * string in the database) into an array format required by the frontend.
     * The method handles null/empty input gracefully and trims whitespace from each skill.
     * 
     * @param skills Comma-separated skills string (e.g., "React, TypeScript, Node.js")
     *               Can be null or empty.
     * @return List of trimmed, non-empty keywords. Returns an empty list if input is null or empty.
     * 
     * @example
     * <pre>
     * String skills = "React, TypeScript, Node.js, Express";
     * List&lt;String&gt; keywords = JobMapper.skillsToKeywords(skills);
     * // Result: ["React", "TypeScript", "Node.js", "Express"]
     * 
     * List&lt;String&gt; empty = JobMapper.skillsToKeywords(null);
     * // Result: []
     * </pre>
     */
    public static List<String> skillsToKeywords(String skills) {
        if (skills == null || skills.trim().isEmpty()) {
            return new ArrayList<>();
        }
        return Arrays.stream(skills.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.toList());
    }

    /**
     * Converts a requirements string to a list of individual requirements.
     * 
     * This method parses a requirements string (stored as text in the database)
     * and splits it into an array format required by the frontend. It handles
     * various formats including:
     * - Newline-separated requirements
     * - Bullet points (•, •, ●)
     * - Numbered lists (1., 2., etc.)
     * - Dash or asterisk lists (-, *)
     * 
     * Requirements with less than 3 characters are filtered out to avoid
     * empty or meaningless entries.
     * 
     * @param requirements Requirements string with multiple requirements.
     *                    Can be null or empty.
     * @return List of trimmed, non-empty requirements (length > 3).
     *         Returns an empty list if input is null or empty.
     * 
     * @example
     * <pre>
     * String requirements = "5+ years of experience\n• React expertise\n• TypeScript knowledge";
     * List&lt;String&gt; reqs = JobMapper.requirementsToArray(requirements);
     * // Result: ["5+ years of experience", "React expertise", "TypeScript knowledge"]
     * </pre>
     */
    public static List<String> requirementsToArray(String requirements) {
        if (requirements == null || requirements.trim().isEmpty()) {
            return new ArrayList<>();
        }
        // Split by newline (\n, \r), bullet points (•, •, ●), numbered lists (1., 2., etc.), or dashes/asterisks (-, *)
        return Arrays.stream(requirements.split("[\n\r•\u2022\u25CF]|\\d+\\.|[-*]"))
                .map(String::trim)
                .filter(s -> !s.isEmpty() && s.length() > 3) // Filter out empty strings and very short entries
                .collect(Collectors.toList());
    }

    /**
     * Formats a Job.JobType enum value to a human-readable string.
     * 
     * This method converts the enum value (e.g., FULL_TIME) to a formatted
     * string suitable for display in the frontend (e.g., "Full-time").
     * Returns an empty string if the jobType is null.
     * 
     * @param jobType The Job.JobType enum value to format. Can be null.
     * @return Formatted job type string:
     *         - FULL_TIME → "Full-time"
     *         - PART_TIME → "Part-time"
     *         - CONTRACT → "Contract"
     *         - INTERNSHIP → "Internship"
     *         - null → ""
     *         - Unknown enum value → enum name as-is
     * 
     * @example
     * <pre>
     * String formatted = JobMapper.formatJobType(Job.JobType.FULL_TIME);
     * // Result: "Full-time"
     * 
     * String empty = JobMapper.formatJobType(null);
     * // Result: ""
     * </pre>
     */
    public static String formatJobType(Job.JobType jobType) {
        if (jobType == null) return "";
        switch (jobType) {
            case FULL_TIME:
                return "Full-time";
            case PART_TIME:
                return "Part-time";
            case CONTRACT:
                return "Contract";
            case INTERNSHIP:
                return "Internship";
            default:
                return jobType.name(); // Fallback to enum name if new type is added
        }
    }

    /**
     * Formats a salary range to a human-readable compensation string.
     * 
     * This method combines minimum salary, maximum salary, and currency code
     * into a formatted string suitable for frontend display. It handles various
     * scenarios:
     * - Both min and max: "$150k–$190k"
     * - Only min: "$150k"
     * - Only max: "Up to $190k"
     * - Neither: "Not specified"
     * 
     * The currency symbol is automatically determined from the currency code.
     * Salary amounts are formatted using formatSalary() (e.g., 150000 → "150k").
     * 
     * @param salaryMin Minimum salary amount (BigDecimal). Can be null.
     * @param salaryMax Maximum salary amount (BigDecimal). Can be null.
     * @param currency Currency code (e.g., "USD", "EUR", "INR"). Can be null (defaults to "USD").
     * @return Formatted compensation string:
     *         - "$150k–$190k" (both min and max)
     *         - "$150k" (only min)
     *         - "Up to $190k" (only max)
     *         - "Not specified" (neither min nor max)
     * 
     * @example
     * <pre>
     * String comp1 = JobMapper.formatCompensation(
     *     new BigDecimal("150000"), 
     *     new BigDecimal("190000"), 
     *     "USD"
     * );
     * // Result: "$150k–$190k"
     * 
     * String comp2 = JobMapper.formatCompensation(
     *     null, 
     *     new BigDecimal("200000"), 
     *     "USD"
     * );
     * // Result: "Up to $200k"
     * 
     * String comp3 = JobMapper.formatCompensation(null, null, "USD");
     * // Result: "Not specified"
     * </pre>
     */
    public static String formatCompensation(BigDecimal salaryMin, BigDecimal salaryMax, String currency) {
        if (salaryMin == null && salaryMax == null) {
            return "Not specified";
        }
        
        String currencySymbol = getCurrencySymbol(currency != null ? currency : "USD");
        
        StringBuilder compensation = new StringBuilder();
        
        if (salaryMin != null) {
            compensation.append(currencySymbol).append(formatSalary(salaryMin));
        }
        
        if (salaryMin != null && salaryMax != null) {
            // Both min and max: "$150k–$190k"
            compensation.append("–").append(currencySymbol).append(formatSalary(salaryMax));
        } else if (salaryMax != null) {
            // Only max: "Up to $190k"
            compensation.append("Up to ").append(currencySymbol).append(formatSalary(salaryMax));
        }
        
        // Note: Additional benefits like "+ equity" can be added here
        // based on business requirements (e.g., from a benefits field)
        
        return compensation.toString();
    }

    /**
     * Formats a salary amount to a compact, readable string.
     * 
     * This private helper method converts a BigDecimal salary amount to a
     * human-readable format:
     * - >= 1,000,000: "1.5M" (millions with one decimal place)
     * - >= 1,000: "150k" (thousands)
     * - < 1,000: "500" (exact amount)
     * 
     * Returns an empty string if the salary is null.
     * 
     * @param salary The salary amount to format (BigDecimal). Can be null.
     * @return Formatted salary string:
     *         - "1.5M" (for amounts >= 1,000,000)
     *         - "150k" (for amounts >= 1,000)
     *         - "500" (for amounts < 1,000)
     *         - "" (if salary is null)
     * 
     * @example
     * <pre>
     * String formatted1 = formatSalary(new BigDecimal("1500000"));
     * // Result: "1.5M"
     * 
     * String formatted2 = formatSalary(new BigDecimal("150000"));
     * // Result: "150k"
     * 
     * String formatted3 = formatSalary(new BigDecimal("500"));
     * // Result: "500"
     * </pre>
     */
    private static String formatSalary(BigDecimal salary) {
        if (salary == null) return "";
        
        long amount = salary.longValue();
        if (amount >= 1000000) {
            // Format as millions with one decimal place (e.g., "1.5M")
            return String.format("%.1fM", amount / 1000000.0);
        } else if (amount >= 1000) {
            // Format as thousands (e.g., "150k")
            return String.format("%dk", amount / 1000);
        } else {
            // Format as exact amount (e.g., "500")
            return String.valueOf(amount);
        }
    }

    /**
     * Gets the currency symbol for a given currency code.
     * 
     * This private helper method maps standard ISO 4217 currency codes to their
     * corresponding symbols. If the currency code is not recognized, it returns
     * the currency code followed by a space as a fallback.
     * 
     * Supported currencies:
     * - USD → "$"
     * - EUR → "€"
     * - GBP → "£"
     * - INR → "₹"
     * - JPY → "¥"
     * - Others → "{CODE} " (currency code with space)
     * 
     * Returns "$" (USD) as the default if currency is null.
     * 
     * @param currency The currency code (e.g., "USD", "EUR", "INR"). Can be null.
     * @return Currency symbol:
     *         - "$" for USD (default if null)
     *         - "€" for EUR
     *         - "£" for GBP
     *         - "₹" for INR
     *         - "¥" for JPY
     *         - "{CODE} " for unrecognized codes
     * 
     * @example
     * <pre>
     * String symbol1 = getCurrencySymbol("USD");
     * // Result: "$"
     * 
     * String symbol2 = getCurrencySymbol("EUR");
     * // Result: "€"
     * 
     * String symbol3 = getCurrencySymbol("CAD");
     * // Result: "CAD "
     * 
     * String symbol4 = getCurrencySymbol(null);
     * // Result: "$"
     * </pre>
     */
    private static String getCurrencySymbol(String currency) {
        if (currency == null) return "$"; // Default to USD
        switch (currency.toUpperCase()) {
            case "USD":
                return "$";
            case "EUR":
                return "€";
            case "GBP":
                return "£";
            case "INR":
                return "₹";
            case "JPY":
                return "¥";
            default:
                // Return currency code with space for unrecognized currencies
                return currency + " ";
        }
    }

    /**
     * Formats an Instant timestamp to a relative time string (e.g., "2 days ago").
     * 
     * This method calculates the time difference between the given Instant and
     * the current time, then formats it as a human-readable relative time string.
     * It handles various time units from years down to minutes, with proper
     * singular/plural formatting.
     * 
     * Time units handled (in order of precedence):
     * - Years: "1 year ago" or "2 years ago"
     * - Months: "1 month ago" or "2 months ago"
     * - Weeks: "1 week ago" or "2 weeks ago"
     * - Days: "1 day ago" or "2 days ago"
     * - Hours: "1 hour ago" or "2 hours ago"
     * - Minutes: "1 minute ago" or "2 minutes ago"
     * - Less than 1 minute: "Just now"
     * 
     * Returns an empty string if the instant is null.
     * 
     * @param instant The Instant timestamp to format (typically createdAt for jobs). Can be null.
     * @return Formatted relative time string:
     *         - "Just now" (less than 1 minute ago)
     *         - "1 minute ago" / "X minutes ago"
     *         - "1 hour ago" / "X hours ago"
     *         - "1 day ago" / "X days ago"
     *         - "1 week ago" / "X weeks ago"
     *         - "1 month ago" / "X months ago"
     *         - "1 year ago" / "X years ago"
     *         - "" (if instant is null)
     * 
     * @example
     * <pre>
     * Instant twoDaysAgo = Instant.now().minus(Duration.ofDays(2));
     * String formatted = JobMapper.formatPostedAt(twoDaysAgo);
     * // Result: "2 days ago"
     * 
     * Instant oneHourAgo = Instant.now().minus(Duration.ofHours(1));
     * String formatted2 = JobMapper.formatPostedAt(oneHourAgo);
     * // Result: "1 hour ago"
     * 
     * String empty = JobMapper.formatPostedAt(null);
     * // Result: ""
     * </pre>
     */
    public static String formatPostedAt(Instant instant) {
        if (instant == null) return "";
        
        Instant now = Instant.now();
        Duration duration = Duration.between(instant, now);
        
        // Calculate time units
        long seconds = duration.getSeconds();
        long minutes = seconds / 60;
        long hours = minutes / 60;
        long days = hours / 24;
        long weeks = days / 7;
        long months = days / 30; // Approximate: 30 days per month
        long years = days / 365; // Approximate: 365 days per year
        
        // Format based on the largest applicable unit
        if (years > 0) {
            return years == 1 ? "1 year ago" : years + " years ago";
        } else if (months > 0) {
            return months == 1 ? "1 month ago" : months + " months ago";
        } else if (weeks > 0) {
            return weeks == 1 ? "1 week ago" : weeks + " weeks ago";
        } else if (days > 0) {
            return days == 1 ? "1 day ago" : days + " days ago";
        } else if (hours > 0) {
            return hours == 1 ? "1 hour ago" : hours + " hours ago";
        } else if (minutes > 0) {
            return minutes == 1 ? "1 minute ago" : minutes + " minutes ago";
        } else {
            return "Just now";
        }
    }

    /**
     * Creates a CompanyDTO from a Job entity.
     * 
     * This method extracts company information from a Job entity and creates
     * a CompanyDTO object with the company name and logo URL. This is used
     * to structure company data as an object (instead of a string) for the frontend.
     * 
     * The method handles null values gracefully:
     * - If job is null, returns null
     * - If company name is null, returns empty string
     * - If logo URL is null, returns empty string
     * 
     * @param job The Job entity containing company information. Can be null.
     * @return CompanyDTO with name and logoUrl fields:
     *         - name: Company name from job.getCompany() (or empty string if null)
     *         - logoUrl: Company logo URL from job.getCompanyLogoUrl() (or empty string if null)
     *         - Returns null if job is null
     * 
     * @example
     * <pre>
     * Job job = new Job();
     * job.setCompany("Acme Corp");
     * job.setCompanyLogoUrl("https://example.com/logo.png");
     * 
     * CompanyDTO company = JobMapper.toCompanyDTO(job);
     * // Result: CompanyDTO{name="Acme Corp", logoUrl="https://example.com/logo.png"}
     * 
     * CompanyDTO nullCompany = JobMapper.toCompanyDTO(null);
     * // Result: null
     * </pre>
     */
    public static CompanyDTO toCompanyDTO(Job job) {
        if (job == null) return null;
        
        return CompanyDTO.builder()
                .name(job.getCompany() != null ? job.getCompany() : "")
                .logoUrl(job.getCompanyLogoUrl() != null ? job.getCompanyLogoUrl() : "")
                .build();
    }

    /**
     * Converts a Job entity to a JobDetailDTO for frontend display.
     * 
     * This is the main transformation method that converts a Job entity into
     * the JobDetailDTO format expected by the frontend JobDetail page. It performs
     * various data transformations:
     * - Converts ID to string
     * - Maps title to role
     * - Creates CompanyDTO object from company name and logo URL
     * - Formats compensation string from salary range
     * - Formats job type enum to readable string
     * - Formats createdAt to relative time string ("2 days ago")
     * - Converts skills string to keywords array
     * - Converts requirements string to requirements array
     * - Includes match score, match factors, and similar jobs (computed externally)
     * 
     * All optional parameters (matchScore, matchFactors, similarJobs, saved) can be null
     * and will be set to default values (0, empty list, false) if not provided.
     * 
     * @param job The Job entity to convert. Cannot be null (returns null if null).
     * @param matchScore The AI-calculated match score (0-100). Can be null (defaults to 0).
     * @param matchFactors List of match factors explaining the match score.
     *                    Can be null (defaults to empty list).
     * @param similarJobs List of similar job opportunities. Can be null (defaults to empty list).
     * @param saved Whether the current user has saved this job. Can be null (defaults to false).
     * @return JobDetailDTO with all fields transformed and formatted for frontend,
     *         or null if job is null.
     * 
     * @example
     * <pre>
     * Job job = jobRepository.findById(1L).orElseThrow();
     * Integer matchScore = 88;
     * List&lt;MatchFactorDTO&gt; factors = calculateMatchFactors(job, user);
     * List&lt;SimilarJobDTO&gt; similar = findSimilarJobs(job.getId());
     * Boolean saved = checkIfSaved(job.getId(), userId);
     * 
     * JobDetailDTO detail = JobMapper.toJobDetailDTO(job, matchScore, factors, similar, saved);
     * // Returns JobDetailDTO with all fields formatted and transformed
     * </pre>
     * 
     * @see #skillsToKeywords(String)
     * @see #requirementsToArray(String)
     * @see #formatCompensation(BigDecimal, BigDecimal, String)
     * @see #formatJobType(Job.JobType)
     * @see #formatPostedAt(Instant)
     * @see #toCompanyDTO(Job)
     */
    public static JobDetailDTO toJobDetailDTO(Job job, Integer matchScore, 
                                              List<MatchFactorDTO> matchFactors,
                                              List<SimilarJobDTO> similarJobs,
                                              Boolean saved) {
        if (job == null) return null;
        
        return JobDetailDTO.builder()
                .id(job.getId() != null ? job.getId().toString() : null) // Convert Long to String for frontend
                .role(job.getTitle()) // Map title to role field
                .company(toCompanyDTO(job)) // Create CompanyDTO object
                .location(job.getLocation())
                .compensation(formatCompensation(job.getSalaryMin(), job.getSalaryMax(), job.getSalaryCurrency()))
                .type(formatJobType(job.getJobType())) // Format enum to readable string
                .postedAt(formatPostedAt(job.getCreatedAt())) // Format to relative time
                .keywords(skillsToKeywords(job.getSkills())) // Convert comma-separated string to array
                .description(job.getDescription())
                .requirements(requirementsToArray(job.getRequirements())) // Convert string to array
                .companyInfo(job.getCompanyInfo())
                .similarJobs(similarJobs != null ? similarJobs : Collections.emptyList()) // Default to empty list
                .matchScore(matchScore != null ? matchScore : 0) // Default to 0
                .matchFactors(matchFactors != null ? matchFactors : Collections.emptyList()) // Default to empty list
                .saved(saved != null ? saved : false) // Default to false
                .build();
    }
}